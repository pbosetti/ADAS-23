---
title: "Serie temporali"
author: "Paolo Bosetti"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(xts)
library(tsbox)
library(astsa)
library(forecast)
library(zoo)
library(ggfortify)
```

# Date

In R ci sono due tipi di oggetti per memorizzare informazioni su tempo: `Date` (con risoluzione fino al giorno) e `POSIXct` (con risoluzione completa fino a frazioni di secondo).

```{r}
today <- Sys.Date()
now <- Sys.time()

today
now

class(today)
class(now)
```
La libreria `lubridate` (parte del Tidyverse) dispone di numerose funzioni per la creazione e la modifica di oggetti temporali. Ad esempio, per creare oggetti di tipo data o tempo:

```{r}
t1 <- dmy("01-01-2023")
t1
t2 <- ymd("2023-6-10")
t2
t3 <- ymd_hm("2023/6/1 10:30")
t3
```
Per estrarre componenti dalle date:

```{r}
year(t1)
month(t2)
wday(t3)
```

Ovviamente sono disponibili operazioni algebriche **vettorializzate** tra oggetti temporali:

```{r}
(today - t1) %>% as.numeric()
```
Anche queste operazioni sono facilitate dalle funzioni `libridate` come `years()`, `months()`, `weeks()`, ecc.:

```{r}
now + months(2)
```
È utile poter arrotondare una data ad una frazione inferiore (`floor_date()`) o superiore (`ceiling_date()`) di un certo periodo, come ad esempio:

```{r}
ceiling_date(today, "weeks")
```
Con l'obiettivo di trattare **serie temporali** è ovviamente importante poter costruire vettori sequenza di istanti successivi, equispaziati. Questi si ottengono con la solita funzione `seq()`:

```{r}
seq(today, to= today + months(1), by="2 days")
seq(now, to=now + minutes(2), by="13 secs")
```
Si noti che per gli oggetti POSIXct il numero di decimali di default è 2. Per aumentarlo:

```{r}
options(digits.secs = 3) # fino all millisecondo
```


# Serie temporali

In R ci sono diverse librerie per la gestione delle serie temporali. La più semplice fa parte di R base ed è la classe `ts`, per *time series*. Un oggetto `ts` si crea con la funzione `ts()`, che vuole un vettore di osservazioni e due qualsiasi tra

* inizio
* fine
* frequenza

Inizio e fine sono passati come vettori di uno o due elementi. Se gli elementi sono due, si assume l'inizio dopo un dato numero di sottoperiodi, ed il numero di sottoperiodi è calcolato sulla base della frequenza. Ad esempio:

```{r}
s1 <- ts(rnorm(20), start = 0, frequency = 10)
s1
```
genera una serie temporale di 20 osservazioni, che inizia all'istante 0 e divide ogni periodo in 10 sottoperiodi.

Questo tipo di struttura è a **passo temporale costante**. È spesso utilizzata per dati annuali, ad esempio: 

```{r}
ts(rnorm(20), start = c(2023, 11), frequency = 12)
```

è una serie temporale mensile che inizia all'undicesimo mese (sottoperiodo) del 2023.

È possibile mettere in grafico immediatamente le serie temporali di tipo `ts` come segue:

```{r}
plot(s1)
```

Inizio, fine e frequenza possono essere estratte con le relative funzioni:

```{r}
start(s1)
end(s1)
frequency(s1)
```
Infine, una `st` può essere convertita in un vettore mediante `as.numeric()`:

```{r}
as.numeric(s1)
```
e il vettore dei tempi (che non è contenuto direttamente nell'oggetto `st`) può essere generato con la funzione `time()`:

```{r}
time(s1)
```

```{r}
s2 <- ts(tibble(
    A=rnorm(10),
    B=runif(10)
  ), 
  start = c(2023, 11), 
  frequency = 12)

s2
```


# Classe `xts`



```{r}
x1 <- xts(
  tibble(A=1:8, B=rnorm(length(A))),
  order.by = seq(
    from = Sys.Date(),
    to = Sys.Date() + weeks(1),
    by = "1 days"
  )
)

x1 %>% ts_ts()
```

```{r}
s2 %>% ts_xts()
```

```{r}
globtemp %>% ts_xts() -> gt
dimnames(gt) <- list(NULL, "temp")
gt["2000/"]
```

```{r}
rollapply(gt, 3, mean, align="left")
```

```{r}
gt %>% rollapply(7, sd) %>% plot()
```

```{r}
x2 <- xts(
  rnorm(365),
  order.by = seq(
    from = ymd("2021-1-1"),
    to = ymd("2021-12-31"),
    by = "1 days",
  )
)

x2 %>% apply.weekly(mean) %>% plot()
```
```{r}
gt %>% lag.xts(10)
```

```{r}
gt %>% diff(differences=1) %>% plot()
```
## Grafici di xts con ggplot

```{r warning=FALSE}
gt2 <- gt
gt2$mean_temp <- rollmean(gt, 9, align="center")

gt2 %>% ggplot(aes(x=Index, y=temp)) +
  geom_line() +
  geom_line(aes(y=mean_temp), color="red") +
  scale_x_date(
    breaks="10 years",
    labels=scales::label_date("%Y")
  ) +
  theme(
    axis.text.x = element_text(angle=45)
  )
```

```{r}
gt2 %>% fortify()
```

# Modelli ARIMA

Simulazione di una ST

```{r}
set.seed(0)
ts <- arima.sim(
  model = list(
    ma = c(0.5, 0.49),
    ar = c(0.7),
    order = c(1, 1, 2)
  ),
  n = 150
)

plot(ts)
```

```{r}
plot(1:10, ARMAacf(ar=c(0.5, 0.3), lag.max = 10, pacf=TRUE), typ="h")
```

```{r}
set.seed(0)
ari <- arima.sim(
  model = list(
    order = c(1, 2, 0),
    ar = c(0.9)
  ),
  n = 300
)

ggtsdisplay(ari, lag.max = 50)

```
```{r}
ggtsdisplay(diff(ari, differences = 2), lag.max = 50)
```

```{r}
ggtsdisplay(diff(log(AirPassengers)))
```
```{r}
apld <- AirPassengers %>% log() %>% diff()

lag.plot(apld, lags=16, do.lines = FALSE)
```
```{r}
fit <- auto.arima(AirPassengers, lambda=0, trace=F)
```

La regressione `fit` può essere passata a `ggplot()` **a patto di aver prima caricato la libreria `ggfortify`**:

```{r warning=FALSE}
forecast(fit,h=20) %>%  
  ggplot(aes(x=Index, y=Data)) + 
  geom_line() +
  geom_line(aes(y=Fitted), color=grey(0.5)) +
  geom_ribbon(aes(ymin=`Lo 80`, ymax=`Hi 80`), fill="blue", alpha = 0.5) + 
  geom_ribbon(aes(ymin=`Lo 95`, ymax=`Hi 95`), fill="blue", alpha = 0.5) +
  geom_line(aes(y=`Point Forecast`), color="blue") 

```


